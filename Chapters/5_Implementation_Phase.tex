	Since there are two different implementations, I have divided the implementational details of the recommenders into two subsections: section \ref{eigentrust_section} and \ref{inverse_section}. Under this subsection, libraries and technologies used in implementations are explained.
	\subsubsection{Neo4j}
	\subparagraph{Driver Installation}:
	\begin{lstlisting}[language=bash]
	pip install neo4j
	\end{lstlisting}
	
	\subparagraph{Configuration}:
	\begin{lstlisting}[language=python]
	import neo4j
	...
	
	uri = self._config["database"]["neo4j"]["uri"]
	user = self._config["database"]["neo4j"]["user"]
	password = self._config["database"]["neo4j"]["password"]
	
	self._driver = neo4j.Driver(uri, auth=(user, password))
	
	\end{lstlisting}
	
	\subparagraph{Sample Usage}:
	\begin{lstlisting}[language=python, caption=Neo4j driver example]
	import neo4j
	...
	
	def get_customer_trust(self, customer_id):
	
	query = (
	f"MATCH (u:Customer)-[r:BELONGS_IN]->(:Community) "
	f"WHERE u.id = {repr(customer_id)} "
	f"RETURN r.eigentrust"
	)
	
	with self._driver.session() as session:
	return tuple(session.run(query).single())
	
	\end{lstlisting}
	
	\subsubsection{Numpy}
	\subparagraph{Installation}:
	\begin{lstlisting}[language=bash]
	pip install numpy
	\end{lstlisting}
	
	\subparagraph{Sample Usage}:
	\begin{lstlisting}[language=python, caption=Numpy example]
	import numpy as np
	
	class TrustBasedFilterer(object):
	...
	
	def _create_customers_versus_products_table(self):
	
	self._customers_versus_products_table = np.zeros(
	(self._unique_customers.shape[0],
	self._unique_products.shape[0]),
	dtype=np.bool,
	)
	
	self._customers_versus_products_table[
	self._sales[:, 0],
	self._sales[:, 1],
	] = True
	\end{lstlisting}
	
	\subsubsection{Scipy}
	\subparagraph{Installation}:
	\begin{lstlisting}[language=bash]
	pip install scipy
	\end{lstlisting}
	
	\subparagraph{Sample Usage}:
	\begin{lstlisting}[language=python, caption=Scipy example]
	from scipy.sparse import csr_matrix
	from scipy.sparse.csgraph import dijkstra
	
	class Graph(object):
	...
	
	def _create_distance_matrix(self):
	
	self._create_adjacency_matrix()
	
	self._adjacency_matrix = \
	csr_matrix(self._adjacency_matrix)
	
	self._distance_matrix = dijkstra( 
	csgraph=self._adjacency_matrix, 
	directed=False, 
	return_predecessors=False, 
	unweighted=True,
	limit=self._max_distance)
	
	self._distance_matrix\ 
	[~np.isfinite(self._distance_matrix)] = 0
	\end{lstlisting}